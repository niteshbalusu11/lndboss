import { createHash, createHmac } from 'crypto';

import derEncodeSignature from './der_encode_signature';

const bufferAsHex = buffer => buffer.toString('hex');
const { from } = Buffer;
const hexAsBuffer = hex => Buffer.from(hex, 'hex');
const hmacSha256 = (pk, url) => createHmac('sha256', pk).update(url).digest();
const sha256 = n => createHash('sha256').update(n).digest();
const utf8AsBuffer = utf8 => Buffer.from(utf8, 'utf8');

/** Sign an authentication challenge for LNURL Auth

  {
    ecp: <ECPair Object>
    hostname: <Domain for Authentication Challenge String>
    k1: <Challenge Nonce String>
    seed: <Seed Signature String>
  }

  @returns
  {
    public_key: <Signing Identity Public Key Hex String>
    signature: <Signature For Authentication Challenge Hex String>
  }
*/
const signAuthChallenge = ({ ecp, hostname, k1, seed }) => {
  // LUD-13: LN wallet defines hashingKey as sha256(signature)
  const hashingKey = sha256(utf8AsBuffer(seed));

  // LUD-13: linkingPrivKey is defined as hmacSha256(hashingKey, domain)
  const linkingPrivKey = hmacSha256(hashingKey, utf8AsBuffer(hostname));

  // Instantiate the key pair from this derived private key
  const linkingKey = ecp.fromPrivateKey(linkingPrivKey);

  // Using the host-specific linking key, sign the challenge k1 value
  const signature = bufferAsHex(from(linkingKey.sign(hexAsBuffer(k1))));

  return {
    public_key: bufferAsHex(linkingKey.publicKey),
    signature: derEncodeSignature({ signature }).encoded,
  };
};

export default signAuthChallenge;
